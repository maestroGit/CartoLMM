// Servicio para refresco reactivo del dashboard y nodos usando WebSocket
// Se integra con el frontend y actualiza la UI en tiempo real

class RealtimeDashboardService {
  constructor({ socket, dashboardService, peersService, mapService }) {
    this.socket = socket;
    this.dashboardService = dashboardService;
    this.peersService = peersService;
    this.mapService = mapService;
    this.lastMetrics = null;
    this.lastPeers = null;
    this.isSocketConnected = false;
    this.pollingInterval = null;
    this.mapUpdateTimeout = null;
    this.mapUpdateDelay = 1000;
  }

  init() {
    this.fetchInitialSnapshot();
    this.setupSocketListeners();
  }

  fetchInitialSnapshot() {
    fetch('/api/dashboard-metrics')
      .then(r => r.json())
      .then(data => {
        if (data.success && this.dashboardService) {
          this.dashboardService.updateMetrics(data.data);
        }
      });
    fetch('/api/peers')
      .then(r => r.json())
      .then(data => {
        if (data.success) {
          if (this.peersService) {
            this.peersService.renderMetricGrid(data);
          }
          if (this.mapService && data.peers) {
            console.log(\`Ì∑∫Ô∏è Cargando \${data.peers.length} peers en el mapa...\`);
            this.mapService.loadPeersOnMap(data.peers);
          }
        }
      });
  }

  setupSocketListeners() {
    if (!this.socket) return;
    this.socket.on('connect', () => {
      this.isSocketConnected = true;
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
      }
    });
    this.socket.on('disconnect', () => {
      this.isSocketConnected = false;
      if (!this.pollingInterval) {
        this.pollingInterval = setInterval(() => this.fetchInitialSnapshot(), 10000);
      }
    });
    this.socket.on('system:metrics', metrics => {
      this.lastMetrics = metrics;
      if (this.dashboardService) {
        this.dashboardService.updateMetrics(metrics);
      }
      if (metrics.peers && this.peersService) {
        this.peersService.renderMetricGrid(metrics.peers);
      }
    });
    this.socket.on('system:peers', peers => {
      this.lastPeers = peers;
      if (this.peersService) {
        this.peersService.renderMetricGrid(peers);
      }
      if (this.mapService && peers && peers.peers) {
        this.scheduleMapUpdate(peers.peers);
      }
    });
  }

  scheduleMapUpdate(peers) {
    if (this.mapUpdateTimeout) {
      clearTimeout(this.mapUpdateTimeout);
    }
    this.mapUpdateTimeout = setTimeout(() => {
      try {
        this.mapService.updatePeersOnMap(peers);
        console.log('Ì∑∫Ô∏è Mapa actualizado con peers WebSocket');
      } catch (error) {
        console.error('‚ùå Error actualizando mapa:', error);
      }
      this.mapUpdateTimeout = null;
    }, this.mapUpdateDelay);
  }
}

window.RealtimeDashboardService = RealtimeDashboardService;

function initRealtimeServiceGlobal() {
  if (!window.socket || !window.dashboardService || !window.peersService || !window.mapService) {
    console.log('‚è≥ Esperando servicios para realtimeDashboardService...');
    setTimeout(initRealtimeServiceGlobal, 100);
    return;
  }
  console.log('Ì¥Ñ Inicializando realtimeDashboardService...');
  const realtimeService = new RealtimeDashboardService({
    socket: window.socket,
    dashboardService: window.dashboardService,
    peersService: window.peersService,
    mapService: window.mapService
  });
  window.realtimeDashboardService = realtimeService;
  realtimeService.init();
  console.log('‚úÖ realtimeDashboardService inicializado');
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initRealtimeServiceGlobal);
} else {
  initRealtimeServiceGlobal();
}
