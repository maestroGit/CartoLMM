// Servicio para refresco reactivo del dashboard y nodos usando WebSocket
// Se integra con el frontend y actualiza la UI en tiempo real

export class RealtimeDashboardService {
  constructor({ socket, dashboardService, peersService, mapService }) {
    this.socket = socket;
    this.dashboardService = dashboardService;
    this.peersService = peersService;
    this.mapService = mapService; // Nuevo: servicio de mapa
    this.lastMetrics = null;
    this.lastPeers = null;
    this.isSocketConnected = false;
    this.pollingInterval = null;
    // Debounce para actualizaciones del mapa
    this.mapUpdateTimeout = null;
    this.mapUpdateDelay = 1000; // 1 segundo de debounce
  }

  // Inicializa listeners y hace fetch inicial
  init() {
    // Fetch inicial de m√©tricas y peers
    this.fetchInitialSnapshot();
    // Suscribirse a eventos WebSocket
    this.setupSocketListeners();
  }

  fetchInitialSnapshot() {
    // Dashboard
    fetch('/api/dashboard-metrics')
      .then(r => r.json())
      .then(data => {
        if (data.success && this.dashboardService) {
          this.dashboardService.updateMetrics(data.data);
        }
      });
    // Peers
    fetch('/api/peers')
      .then(r => r.json())
      .then(data => {
        if (data.success) {
          // Actualizar sidebar
          if (this.peersService) {
            this.peersService.renderMetricGrid(data);
          }
          // Actualizar mapa
          if (this.mapService && data.peers) {
            this.mapService.loadPeersOnMap(data.peers);
          }
        }
      });
  }

  setupSocketListeners() {
    if (!this.socket) return;
    this.socket.on('connect', () => {
      this.isSocketConnected = true;
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
      }
    });
    this.socket.on('disconnect', () => {
      this.isSocketConnected = false;
      // Si se pierde el socket, vuelve a hacer fetch cada 10s
      if (!this.pollingInterval) {
        this.pollingInterval = setInterval(() => this.fetchInitialSnapshot(), 10000);
      }
    });
    // Evento de m√©tricas en tiempo real
    this.socket.on('system:metrics', metrics => {
      this.lastMetrics = metrics;
      if (this.dashboardService) {
        this.dashboardService.updateMetrics(metrics);
      }
      // Si el evento incluye peers, refresca tambi√©n
      if (metrics.peers && this.peersService) {
        this.peersService.renderMetricGrid(metrics.peers);
      }
    });
    // Evento de peers en tiempo real (si existe)
    this.socket.on('system:peers', peers => {
      this.lastPeers = peers;
      // Actualizar sidebar
      if (this.peersService) {
        this.peersService.renderMetricGrid(peers);
      }
      // Actualizar mapa con debounce
      if (this.mapService && peers && peers.peers) {
        this.scheduleMapUpdate(peers.peers);
      }
    });
  }

  /**
   * Programa actualizaci√≥n del mapa con debounce
   * @param {Array} peers - Array de peers
   */
  scheduleMapUpdate(peers) {
    // Cancelar actualizaci√≥n pendiente
    if (this.mapUpdateTimeout) {
      clearTimeout(this.mapUpdateTimeout);
    }
    
    // Programar nueva actualizaci√≥n
    this.mapUpdateTimeout = setTimeout(() => {
      try {
        this.mapService.updatePeersOnMap(peers);
        console.log('üó∫Ô∏è Mapa actualizado con peers WebSocket');
      } catch (error) {
        console.error('‚ùå Error actualizando mapa:', error);
      }
      this.mapUpdateTimeout = null;
    }, this.mapUpdateDelay);
  }
}

// Ejemplo de uso en el frontend:
// import { RealtimeDashboardService } from './src/services/realtimeDashboardService.js';
// const realtime = new RealtimeDashboardService({ socket, dashboardService, peersService });
// realtime.init();
